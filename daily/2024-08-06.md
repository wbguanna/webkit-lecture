### 1교시
todolist
간단하게 todo 추가하는 것 만들고
list를 array로 저장하게 바꾼후
객체 (window단)로 list 항목을 만들어 전달하는 것 함

### 2교시 
todolist
appendChild 자세히 보기

HTMLElement 
property를 보면서 고치셨다


day09ex01_step3.html


day09ex01_step4.html
 - checkbox setAttribute 추가
 - spanTag okTitle 추가

	10:33
	dom을 이용했을때는 ?


### 3교시 정리
https://velog.io/@reasonz/2022.05.18-DOM-Document-%EA%B0%9D%EC%B2%B4%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C


	`NodeList`는 변경된 태그가 실시간으로 반영되지 않고 
	(정적 콜렉션) `HTMLCollection`은 실시간으로 변경된 태그도 반영이 된다.
	그렇기 때문에 HTMLCollection은 노드의 인덱스 값이 항상 일정하지 않다.  
	(참고 : NodeList는 Node.childNodes만 실시간으로 반영된다.)

안그래도 
querySelector() 로 li 를 잡아 class


### 4교시

개발자가 되기 위해서 피해야 할 사람들 (손절 1순위?)
- 패배의식이 있는 사람...
- 부정적인 사람
- 냉소적인 사람

창의적이고 긍정적이고..
마음가짐이 되어 있어야 한다...

js switch
js function
Array? function? arguments length name 이 들어가있다..?

prototype
``` js
      // 입력 배열
      const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

      Array.prototype.extractOddArray = function () {
        console.log(this);
        return;
      };
      // 함수 호출하여 짝수 추출
      const evenArray = extractEvenNumbers(numbers);
      const oddArray = function print(data, mode) {
```


window.document > Array
dom 객체이기때문에 브라우저 탭 문서 내부에서 사용가능하다...

메소드 체이닝 (js 함수 모듈화시키기..?)

``` js
      Array.prototype.extractEvenArray = () => {
        if (this.length != 0) return -1;
        const evenNumbers = this.filter((num) => num % 2 === 0);
        return evenNumbers;
      };

      Array.prototype.extractOddArray = function () {
        // console.log(this);
        const evenNumber = this.filter((num) => num % 2 !== 0);
        return;
      };

      Array.prototype.print = function (data, mode) {
      ... 중략
      };
```

이렇게 함수를 구성하면

``` js
      const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

      // 함수 호출하여 짝수 추출
      const evenArray = numbers.extractEvenArray(numbers);
      var oddArray = numbers.extractOddArray();
      // console.log("입력 배열:", numbers);
      // console.log("짝수 배열:", evenArray);
      // console.log("홀수 배열:", oddArray);

      oddArray.print(1);
      evenArray.print(1);
```

이렇게 구성이 가능하다..
자바의 toString 과 비슷하다..


### 5교시
해보니까 실행이 안되더라... ㅋㅋㅋ
```js
      Array.prototype.extractEvenArray = () => {
        console.dir(this);
        if (this.length != 0) return -1;
        const evenNumbers = this.filter((num) => num % 2 === 0);
        return evenNumbers;
      };

      Array.prototype.extractOddArray = function () {
        const evenNumber = this.filter((num) => num % 2 !== 0);
        return;
      };

```

IIFE 즉시실행함수 ()로 묶어주면 바로 실행됨

화살표 함수는 선언되는 시점에서 this가 결정이 된다...


##### js 에서의 생성자
``` js
      // 옛날 방식의 클래스 선언(function 생성자 만들기)
      function People(name, age) {
        this.name = name;
        this.age = age;

        function showInfo() {
          // 옛날에는 안에다가 안만들었음 // 내부에 메서드를 선언한 것은 비추
          // 내부에 선언 하면 모든 객체?에 소스가 복제된다..
          // so, prototye에 메서드 선언하는 것을 추천...
        }
      }
      People.prototype.display = function () {
        // console.log(name, age); // 이러면 출력될까? // no
        console.log(this.name, this.age); // yes
        // 멤버메서드에서 멤버 속성을 접근하기위해 this 필수..
      };

      const myPeople = new People("ljw", 13); // new 로 생성
      myPeople.display();
```

##### js의 상속?

``` js       
	// People 상속 받아서 다른 클래스 선언
  // 옛날 방식은 prototype을 이용한 상속
  // prototype

  // 상속? // 생성자는 상속 안된다 // prototype을 공유하는 개념..
  function Student(name, age, grade) {
	this.name = name;
	this.age = age;
	this.grade = grade;
  }
  Student.prototype = new People(); // 프로토타입을 부모의 객체로 쓴다..
  Student.constructor = Student; // 생성자는 Student 함수 자체를 넣어준다.

  const student1 = new Student("일지환", 22, 3);
  const student2 = new Student("이지환", 26, 4);
  student1.display();
  student2.display();
```

생각보다 옛날방식으로 작성된 소스가 많이 있을수 있으니 잘 참고하자...

앞으로 리액트, nodejs가 남아있으니 js 정확히 공부해가야겠지...?

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
<script>
    // 옛날 방식의 클래스 선언(function 생성자 만들기)
    function People(name, age) {
        this.name = name;
        this.age = age;

        function showInfo() {
            // 내부에 선언 하면 모든 객체에 소스가 복제된다.
            // 내부에 메서드를 선언한것은 비추
            // prototype에 메서드 선언하는 것을 추천.
        }
    }
    People.prototype.display = function() {
        // 멤버 메서드에서 멤버 속성 접근하기 위해 this 필수.
        console.log(this.name, this.age);
    }

    People.prototype.method2 = function() {
        // 객체의 멤버를 호출 할때 this. 필수.
        this.display();
    }

    const p1 = new People("이순신", 44);
    p1.display();
    p1.method2();

    // People 상속 받아서 다른 클래스 선언
    // 옛날 방식은 prototype을 이용한 상속
    function Student(name, age, grade) {
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
    Student.prototype = new People();
    Student.constructor = Student;

    const student1 = new Student("일지매", 22, 3);
    student1.display();

    // ES6 에서 클래스 선언
    class 클래스명 {
        constructor() {
            this.속성1 = "값";
            this.속성2 = "값";
        }

        fn01() {
            // 메서드 선언
        }
    }
</script>

</body>
</html>

```