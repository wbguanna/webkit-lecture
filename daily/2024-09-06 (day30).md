
자바 디자인 패턴의 집약체 => Spring

자바에서 어노테이션도 학습했다면 좋지만
Spring framework 중고급 개발자로 만들어 드립니다..
JAVAEE 패턴..
반복해서 계속 찾아보고 만들어봐야함...

todolist, shopping mall ...
익숙해지면 내가 잘하는
내일은 주말이다... 좆됐다..

계속 트레이닝 시켜주고 싶지만.. 그건 알아서 해야할듯하다..
응원한다...
숨쉬는 법을 알려줬으면 숨은 본인이 쉬어야 하는거 아닌가...

![[Pasted image 20240906100959.png]]

![[Pasted image 20240906100952.png]]

### DI : 의존성 주입 (Dependency Injection)

IoC : 제어의 역전... (Inversion of Control)


객체 생성시 new 키워드로 생성시킨다..
이것도 new 키워드와 생성자에 직접적인 의존성이 생겼다..
이것을 외부에서, 그리고 공통적, 가변적으로 생성하기 위해 

[[2024-09-06 (day30)#외전_DI]]

![[Pasted image 20240906095058.png]]

- Dependency Lookup ?
- Dependency Inversion?

##### DI 예시
``` java
interface DbConnector {
    Connection connect();
    void disconnect(Connection conn);
}

class OracleConnector implements DbConnector {}

class MySqlConnector implements DbConnector {}

public class Order {
    private DbConnector dc;

    public Order() {
		// 클래스 내부에 의존성이 발생한다.
		// 유지보수 할 때 Oder클래스 항상 수정, 컴파일 해야 한다.
		// 만약 다른 DB Connector()로 교체 하려고 한다면 Order자체를 수정.
		// 개선 방법은 외부에서 의존성 객체를 주입하는 방식으로 변경.
        dc = new OracleConnector();
    }

    public void processOrder() {
        Connection conn = dc.connect();
        // 주문 처리 로직
        dc.disconnect(conn);
    }
}
```

개선
``` java
interface DbConnector {
    Connection connect();
    void disconnect(Connection conn);
}

public class Order {
    private DbConnectordc;
    
    public Order(DbConnectordc) {
				// 외부에서 Order 객체를 생성 할 때 의존성 객체를 인자로 주입.
				// 의존성 주입(DI): 외부에서 의존성 객체를 인자로 주입.
        this.dc = dc;
    }

	public void setDatabaseConnector (DbConnectordc) {
			this.dc = dc;
	}

    public void processOrder() {
        Connection conn = dc.connect();
        // 주문 처리 로직
        dc.disconnect(conn);
    }
}
```



세상의 가장 큰 진리.. 세상은 변한다.. Spring 도 변하겠지만..

#SW_개발의_기본원칙
SW 개발의 기본원칙 : 
 - 결합도는 낮추고 응집력은 높여야 한다.. (lose coupling)
 - SOLID 원칙..

애초에 모듈 형태로 만들어져 있다면 협업이 쉽다..



옛날에는 하나하나 다 봐야 했지만 이젠 jpa를 이용한다면 구현자체는 쉽다..

### 설정 및 구성..
application.properties / application.yml
또는 @Configuration 어노테이션, 자바 Bean 설정으로 처리..

우리는 XML 설정을 이용해 DI 설정... (실제 프로젝트에서는 어노테이션을 자주 쓸거임..)

이 부분에서는 웹프로젝트로 진행하지 않는다...
``` yml
# 이렇게 두면 spring은 바로 꺼진다..

spring:
	main:
		web-application-type:none
```

![[Pasted image 20240906102432.png]]


``` java
package com.example.demo.controller;

import com.example.demo.service.GreetingService;

public class HomeController {
	// DI는 생성자를 이용한 DI, setter를 이용한 DI로 2가지 방식이 있다..
	// 상속받았으니 같은 타입으로 묶인다.. (전략패턴)
	
	private GreetingService service;
	
	public HomeController(GreetingService greetingService) {
		this.service = greetingService;
		System.out.println("##### HomeController 생성자");
		
		execute();
	}

	private void execute() {
		service.sayHello();
	}
}
```

#질문사항 
HomeController 에서 execute() 함수 따로 분리한 이유..?

setter를 사용하는 DI
``` java
public class HomeController {

	private GreetingService service;
// 생략...
// 여기는 setter를 이용한 DI
	public void setService(GreetingService service) {
		this.service = service;
	}
// 생략...
}
```


거의 90프로는 생성자를 이용한 DI를 자주 사용한다..

``` java
@SpringBootApplication
@ImportResource("classpath:applicationContext.xml")
public class DemoDiApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoDiApplication.class, args);
	}
}
```

@ImportResource() 를 이용하여 최종 빌드시 WEB-INF 로 리소스가 들어가도록.. 만들어 준다..
jsp를 쓰면 war 파일로 생성한다...
실행가능한 jar 파일로 생성하려면 jsp 보다는 다른 템플릿 엔진을 쓰자..

#### xml Bean을 이용한 DI - Spring Framework 에서 쓰던 방식..

![[Pasted image 20240906110320.png]]

``` xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="greetingService1" class="com.example.demo.service.GreetingServiceEng"></bean>
	<bean id="greetingService2" class="com.example.demo.service.GreetingServiceKor"></bean>
	

	<!-- // 컨트롤러에서 클래스, 멤버메소드, 필드에 대한 정보 가져온다.. -->
	<bean id="homeController" class="com.example.demo.controller.HomeContrller">
		
		<!-- 생성자를 이용한 DI -->
		<!-- // ref로 DI 할 값을 찾는다.. -->
		<constructor-args ref="greetingService1"></constructor-args>
		
		<!-- setter를 이용한 DI -->
		<property name="service" ref="greetirngService2"></property>
	</bean>	
</beans>
```
원래 같은 항목에 대해 setter/ constructor DI를 동시사용하는 것은 동작하지 않는다?
동작은 하지만 크게 의미 없다..

xml은 정적인데 실행중에 바뀔수가 있나요? #질문사항

bean 객체 heap에 올라가겠지?
그런데 xml 실행될떄


#### @Autowired 어노테이션 springboot 방식
##### DI Bean 종류
1. **@Component**: 
   - 이 어노테이션은 개발자가 작성한 클래스를 스프링 빈으로 등록합니다. 보통 이 어노테이션을 직접 사용하지 않고, 하위 어노테이션인 @Controller, @Service, @Repository 등을 사용합니다.
2. **@Controller**: 
   - 이 어노테이션은 스프링 MVC에서 컨트롤러 클래스를 나타냅니다. 스프링이 해당 클래스를 검색하고 빈으로 등록합니다.
3. **@Service**: 
   - 이 어노테이션은 비즈니스 로직이 있는 서비스 클래스를 나타냅니다. 이 또한 스프링이 해당 클래스를 검색하고 빈으로 등록합니다.
4. **@Repository**: 
   - 이 어노테이션은 데이터베이스와 관련된 작업을 처리하는 데 사용되는 클래스를 나타냅니다. 주로 DAO(Data Access Object) 클래스에 사용되며, 스프링이 해당 클래스를 검색하고 빈으로 등록합니다.
5. **@Configuration**: 이 어노테이션은 Java Config 클래스를 나타냅니다. 이 클래스는 빈을 정의하고 설정할 때 사용됩니다.
6. **@Bean**: 이 어노테이션은 메서드가 스프링 컨테이너에 의해 관리되는 빈을 생성하고 반환하는 메서드임을 나타냅니다. @Configuration 어노테이션이 적용된 클래스 내에서 사용됩니다.
7. **@ComponentScan**: 이 어노테이션은 스프링이 컴포넌트를 검색하는 범위를 지정합니다. 이 어노테이션을 사용하면 특정 패키지나 클래스를 기준으로 컴포넌트를 검색할 수 있습니다.
8. **@Import**: 이 어노테이션은 다른 설정 클래스를 가져와서 현재 설정 클래스에 포함할 때 사용됩니다.

어렵게 생각하지 말고 이런

#####  예제- 경우1

DI 해줄 부분에 @Autowired 를 등록해준다
``` java
@Controller
public class HomeController {

	// 필드 주입
	@Autowired
	private GreetingService service;
	public HomeController(GreetingService greetingService) {
		this.service = greetingService;
		System.out.println("##### HomeController 생성자");
		
		execute();
	}
	private void execute() {
		service.sayHello();
	}
}
```


경우1
GreetinServiceEng/Kor 중 Eng 하나에만 @Service 가 붙어있는경우 : Eng가 들어간다..
``` java
public interface GreetingService {
	void sayHello();
}

@Service
public class GreetingServiceEng implements GreetingService{ /*...*/ }
public class GreetingServiceKor implements GreetingService{ /*...*/ }
```

경우2
아래처럼 두개의 서비스가 겹치는 경우
``` java
@Service
public class GreetingServiceEng implements GreetingService{ /*...*/ }

@Service
public class GreetingServiceKor implements GreetingService{ /*...*/ }
```


``` java
@Autowired
@Qualifier("GreetingServiceKor")
private GreetingService service;
```

![[Pasted image 20240906112521.png]]


생성자를 lookup 해서 사용도 가능하다
#보충하기 

@Primary
@Qualifier - Bean 이름을 설정해주어야 한다..?
@Component 

#### DL 방식으로 controller 실행?
![[Pasted image 20240906114048.png]]


### Bean 라이프사이클, Scope

``` java
@Component
public class LifeCycleBean {

    public LifeCycleBean() {
        System.out.println("Bean is being constructed.");
    }

    @PostConstruct
    public void postConstruct() {
        System.out.println("Bean is being initialized.");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("Bean is being destroyed.");
    }
}
```

##### SingletonBean vs PrototypeBean
외부에서 객체 생성불가능한 방식
왜 이렇게 쓰느냐?
객체가 여러 개가 생성된다면 낭비가 심한경우가 있다..
여러군데서 하나만 호출 해야하는 경우..

그러나 Singleton이 아닌방식으로 개발해야하는 경우..?
PrototypeBean
``` java
@Component
@Scope("prototype")
public class PrototypeBean {
    private static int instanceCounter = 0;
    private int instanceNumber;

    public PrototypeBean() {
        instanceCounter++;
        instanceNumber = instanceCounter;
        System.out.println("PrototypeBean instance #" + instanceNumber + " created.");
    }
}
```

### lombok에서 DI 사용하기 + JUnit
intelliJ 는 기본사용이지만
vsc, sts 는 lombok을 따로 플러그인 설치를 해주어야 했다..

``` xml
<!--day29 : STS에 설치했을때..-->
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<optional>true</optional>
</dependency>


<!--day30 : java 등록했을떄 : java -jar lombok.jar  -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.22</version>
    <scope>provided</scope>
</dependency>
```

##### JUnit


### AOP

![[Pasted image 20240906140835.png]]

- **Aspect**: 횡단 관심사의 **모듈화 단위**. 로깅, 트랜잭션 등의 기능을 정의한 **클래스**입니다. (할일)
- **Join Point**: Aspect가 적용될 수 있는 **위치**. 메서드 호출, 필드 접근 등이 될 수 있습니다.
- **Advice**: Aspect의 **동작을 정의한 메서드**. 특정 Join Point에 실행되는 코드입니다.
- **Pointcut**: 어느 Join Point에서 Advice를 실행할지를 **정의한 표현식**(셀렉터). 특정 메서드 호출, 패키지 등을 지정할 수 있습니다.
- **Weaving**: Aspect를 핵심 비즈니스 로직에 적용하는 과정. 컴파일 타임, 로드 타임, 런타임 등에서 가능합니다.
![[Pasted image 20240906141225.png]]


ex) 정규표현식을 쓴다고 하면 어떤 패턴을 세밀하게 조정가능하듯..
ex) 성이 "김"씨만 회의채팅에 1 이라고 올려라, 조금더 디테일하게 대가대 박씨 찾습니다

서블릿filter나 express router 도 aop 라고 할수 있나요?
filter - 요청과 응답사이에서만 끼어들어서 

method의 리턴형 매개변수


spring security / spring transaction ..

##### Spring AOP - execute()

``` java
execution([접근 제어자 패턴] 리턴 타입 패턴 [패키지 및 클래스 패턴].메서드 이름(매개변수 패턴))
```

#### 실습 : AOP
pom.xml 에 "spring-boot-starter-aop" 추가..








# 외전


### 질문
- 서블릿filter나 express router 도 aop 라고 할수 있나요?
- 그럼 딱 Lombok 같은거라고 보면 되나요?
	- 이벤트 핸들러 걸어놓듯이 되지만
	- pointcut으로 정규표현식같이 
	- 어떤 메서드, 어떤 패키지, 어떤 클래스의 내용이 실행되게 할거냐를 지정해 줄 수 있음
	- 실행시점(+조건)(why/when), 실행 내용(what/how)
	- 2000개 있는 메서드를 기계어로 직접 코딩한다고 생각해봐라..
		- 딱 비즈니스로직에서 동작하는 관심사를 공통적으로 관리해서 재사용 가능한 모듈
		- 을 말하는 것 같다
		- 
### 김범준 강사님 어록..

심심한 사과 == 사과는 심심하다 (ㅋㅋ)
코딩하는 거 재밌으면 게임하는 애들이 초딩으로 보인다ㅋㅋ
현실세계에서 벗어나서 가상세계로 가려고 한다?
인공지능도 이제 조금 유행이 지나간다..
메타버스..? 유행이 이미 지나갔다..
인플레이션이 이제 끝난다?
요즘은 현실적인 기술들이 다시 올라오고 있다..
웹프로그래밍은 항상 필요하다..

###### 외전_DI
```
Spring Boot 는 어렵진 않다
빌드 자동화가 생소하니 적응하기 어렵다..
aop 패턴은 다 있다..
특정 언어에만 국한된게 아니다..
@Autowire 설명하기 위해서 AOP, DI 설명하는 것
```


니가 동물이 아니라 사람이라면 패턴을 읽고 빠르게 파악한다..
~~이미 금수 생활패턴~~
뭘 하던 재밌는 일을 찾아라..
업무 프로세스를 빨리 파악하고 적응하는 것이 중요하다..
프론트->node백엔드->jsp & spring
빠른 프로세스에 적응해야 한다..
빨리빨리 많이 하는것.. 특히 자기스스로
수업만으로는 부족하다...
쓰면서 배운 거를 써보는 것. 크기는 중요하지 않지만, 자기가 고민해보면서 사용하기..

주말에 Servlet 으로 구현해보기..

프로그래머라면 그림을 그려보는 것도 중요하다..
SW 개발은 기술이다.. 스끼리다.. 근데 미술도 기술이다..
박영만 전산원에 있었다..? 일단 연필하고 지우개 들고 해봐라?
자료구조 그리기
http://www.parkcom.co.kr/

요즘은 클라우드 환경으로 그릴수 있는 도구들이 많다..
피그마, ERDcloud ..

나랑 실력이 비슷한 사람들이 만든 것을 봐야한다..
나는 한게 없는데? 

```
개발할 때 LOOSE COUPLING 
어디 공장에서 문제가 났다? 그럼 다 뜯어보고 고친다..
Spring 소스코드 뜯어보기..?
```

차를 정비할때 딱 보고 나사하나 조이는데 20만원..
공장에서 이미 모듈형태로 나오고 차 수리하는 사람도 보고 고친다


```
sts 에서는 xml classpath 에도 link가 걸린다..
```

개천에서 용난다?
인도-카스트제도.. 그런데 공대가 유명하다
lg 개발할때는 인도개발자들이 많더라...

내가 하고싶은거 한다?
열심히 좀 해라 그럼 마음 먹은거 될 거다..

### 이클립스-STS 사용법

- 쉽게 의존성 추가하는 방법
![[Pasted image 20240906114429.png]]

### 오류
aop
``` log
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sampleController' defined in file [D:\temp\ljw\webkit640\workspace-spring-tool-suite-4-4.24.0.RELEASE\demo-aop-test\target\classes\com\example\demo\controller\SampleController.class]: Failed to instantiate [com.example.demo.controller.SampleController]: Constructor threw exception

at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1337) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1222) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:562) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971) ~[spring-context-6.1.12.jar:6.1.12]

at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625) ~[spring-context-6.1.12.jar:6.1.12]

at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[spring-boot-3.3.3.jar:3.3.3]

at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.3.3.jar:3.3.3]

at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.3.3.jar:3.3.3]

at org.springframework.boot.SpringApplication.run(SpringApplication.java:335) ~[spring-boot-3.3.3.jar:3.3.3]

at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363) ~[spring-boot-3.3.3.jar:3.3.3]

at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352) ~[spring-boot-3.3.3.jar:3.3.3]

at com.example.demo.DemoAopTestApplication.main(DemoAopTestApplication.java:10) ~[classes/:na]

at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]

at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]

at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]

at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]

at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50) ~[spring-boot-devtools-3.3.3.jar:3.3.3]

Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.example.demo.controller.SampleController]: Constructor threw exception

at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:221) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:94) ~[spring-beans-6.1.12.jar:6.1.12]

at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1331) ~[spring-beans-6.1.12.jar:6.1.12]

... 22 common frames omitted

Caused by: java.lang.Error: Unresolved compilation problems:

Service cannot be resolved to a type

Service cannot be resolved to a type

  

at com.example.demo.controller.SampleController.<init>(SampleController.java:16) ~[classes/:na]

at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:na]

at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77) ~[na:na]

at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:na]

at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499) ~[na:na]

at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480) ~[na:na]

at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:195) ~[spring-beans-6.1.12.jar:6.1.12]

... 24 common frames omitted
```

### 학습 내용 리뷰 및 요약

1. **DI(Dependency Injection) 개념 소개:**
    - DI는 의존성을 외부에서 주입하는 방식으로, 코드의 결합도를 낮추고 유지보수성을 높입니다.
    - 필요성: 코드 재사용, 모듈화, 테스트 용이성 등.
2. **DI 종류와 `@Autowired` 어노테이션:**
    - 생성자 주입, 필드 주입, 메서드 주입 등 DI 종류 소개.
    - **`@Autowired`** 어노테이션으로 의존성 주입.
    - 의존성 주입 방식 선택 기준.
3. **Spring Starter Project 생성 및 설정:**
    - Spring Starter Project 생성 방법과 프로젝트 구조 소개.
    - **`pom.xml`**을 통한 Spring Boot 의존성 관리.
4. **의존성 주입 실습:**
    - **`@Autowired`** 어노테이션을 이용한 필드 주입 실습.
    - 생성자 주입을 이용한 DI 실습.
5. **Bean 라이프사이클과 Scope:**
    - Spring Bean의 라이프사이클 이해.
    - Singleton, Prototype 등의 Scope 설명.
    - **`@PostConstruct`**와 **`@PreDestroy`** 어노테이션 활용.
6. **프로젝트에 DI 적용하기:**
    - 기존 프로젝트에 DI 적용하는 방법.
    - Service 계층과 Controller 계층 작성 및 의존성 주입.
7. **Spring Boot AOP 소개:**
    - AOP (Aspect-Oriented Programming) 개념 소개.
    - Spring AOP의 특징과 동작 원리.
8. **AOP 실습:**
    - Logging 관점에서 AOP 적용 실습.
    - **`@Aspect`**, **`@Pointcut`**, **`@Before`** 어노테이션 사용.
9. **Spring Boot에서의 XML 설정과 AOP:**
    - Spring Boot에서도 XML 설정 파일을 사용하여 DI 및 AOP 적용 가능.

# 수업공지
- 다음주에는 교수님 면담 일정 빼놓기..
- 팀짜놓기
- 연락, 질문, 대면상담 일단 가능은 하다...
#### 강사님.. 다음 주차 예고..
- 앞으로 앱을 살짝 건드려본다..
- mac 설치가 되어있지 않다면 xcode 같은거 쓰기가 힘듦
- 요번 주말사이로 만들어 오기..
- 이왕 안드로이드 개발.. swift 도 개발해야한다..
- ios 개발자도 별로 없어서 인건비가 높다...
- 난이도도 높다..?

- myBatis + spring boot 
- 아무래도 springBoot 에도  jpa 가 좋지만 모른다면 my batis도 나쁘지 않다..
- https://cute-almanac-e54.notion.site/8-Spring-Boot-JPA-Security-5e86ca4c31744af593102912f6207467?pvs=97#2e5af9e03b564d4f91ef44251eb55dd9
- jpa는 hibernate 와 같지는 않지만 hibernate의 영향을 많이 받고 있다..


- 이미 전부 만들어 져있는데 왜 만들지를 못하니...
- 가가 가가가 (걔가 거 가서) / 가가가 가가 (저 가서 가져가) 
- 같은 방언을 설정 해 줘야한다.. (application.properties - jpa 설정)
	- spring.jpa.hibernate.ddl-auto=create (자동으로 생성)
	- spring.jpa.defer-datasource-initialization=true 
- 사실 spring boot에도 h2 db가 내장돼 있다.. (in-memory 저장방식)
- embed h2 - in memory : jdbc.h2.console/mem/
- h2 server - localhost


- 고급 개발자가 중요하기보다 사실 만드는게 중요한거 아닌가...
- 돈 잘 벌어다 주는 개발자..?
-

- XMLHttpRequest / Patch 나 요런 부분들

- 영화 역린, 중용23장?
- 젊은 사람들은 고개를 빳빳히 세워야 한다..?
- 선택과 집중..? 이래사나 저래사나 똑같다?
- 구미에서 서울가보면 미친놈들 많다..
- 규정속도 지켜서가는거나 큰 차이 없다..
- 한 우물? 
- 세뇌를 하는지 사기를 치는지 모르겠지만..? ㅋㅋ
- 미쳐야 강하다!!
- 
	- ![[Pasted image 20240906163709.png]]
-  관상 공부좀 해봤는데 
- 장년기가 전성기려면 여름?
- 일단 전화위복이란 말이 괜히 있는게 아니다?
- 평생 고생만하는 사람도 있다ㅋㅋ 난가?ㅋㅋㅋ
- 



# 추가
- todolist를 만들때 필요한 자세
- https://techblog.woowahan.com/2672/